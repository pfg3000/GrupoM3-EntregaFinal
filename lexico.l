%{

//=================================================================================
//	Lenguajes y compiladores
// 	Grupo : M3
//	Temas especiales: AVG INLIST
//================================================================================= */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include "y.tab.h" //generated by bison -d
void yyerror(char *msg);
char *ptr;
long ret;
%}

%option noyywrap
%option yylineno

INICIO_COM				"-\/"
FIN_COM					"\/-"
SINCERO         		[1-9]
DIGITO					[0-9]
LETRA					[a-zA-Z]
BOOLEANO 				true|false
ENTERO          		-?{SINCERO}+{DIGITO}*|0
REAL            		-?{DIGITO}*["."]{DIGITO}+
STRING         			[\"]([^"]|\\.)*[\"]
COMENTARIO				{INICIO_COM}.*{FIN_COM}
ID          			{LETRA}({LETRA}|{DIGITO}|[_-])*
%%
write|WRITE 			{	return WRITE;	}
read|READ    			{	return READ;	}
float|FLOAT    			{	return FLOAT;	}
int|INT        			{	return INT;		}
bool|BOOL				{	return BOOL;	}
string|STRING  			{	return STRING;	}
if|IF          			{	return IF;		}
else|ELSE     			{	return ELSE;	}
while|WHILE    			{	return WHILE;	}
DEFVAR      			{	return DEFVAR;	}
ENDDEF      			{	return ENDDEF;	}
","         			{	return COMA;	}
":"         			{	return D_P;	}
";"         			{	return PUNTO_Y_COMA;	}
"("         			{	return P_A;	}
")"         			{	return P_C;	}
"["  					{	return C_A;	}
"]"						{	return C_C;	}
"{"         			{	return L_A;	}
"}"         			{	return L_C;	}
"++"        			{	return OP_CONCAT;	}
"+"         			{	return OP_SUM;	}
"-"         			{	return OP_RES;	}
"/"         			{	return OP_DIV;	}
"*"         			{	return OP_MUL;	}
"INLIST"				{	return INLIST;	}
"AVG"					{	return AVG;	}
"AND"					{	return AND;	}
"OR"					{	return OR;	}
MOD         			{	return MOD;	}
DIV         			{	return DIV;	}
">"         			{	return CMP_MAY;	}
"<"         			{	return CMP_MEN;	}
">="        			{	return CMP_MAYI;	}
"<="        			{	return CMP_MENI;	}
"!="        			{	return CMP_DIST;	}
"=="        			{	return CMP_IGUAL;	}
":="        			{	return ASIG;	}
{ENTERO}    			{
							strcpy(yylval.s, yytext);
							int casteado = atoi(yytext);
							if(casteado < -32768 || casteado > 32767) {
								char msg[100];
								sprintf(msg, "ERROR Lexico - Entero \'%d\' fuera de rango. Debe estar entre [-32768; 32767]", casteado);
								yyerror(msg);
							}
							return ENTERO;
						}
{BOOLEANO}				{	strcpy(yylval.s, yytext);	
							return BOOLEANO;	}
{REAL}      			{
							strcpy(yylval.s, yytext);	
							double casteado = atof(yytext);
							if(casteado < -32768.000000 || casteado > FLT_MAX) {
								char msg[100];
								sprintf(msg, "ERROR Lexico - Float \'%f\' fuera de rango. Debe estar entre [-32768.000000; 3.40282e38]", casteado);
								yyerror(msg);
							}
							return REAL;
						}
{STRING}    			{	strcpy(yylval.s, yytext);
							int longitud = strlen(yytext);
							//en lugar de 30 verifica con 32 porque el string viene entre comillas
							if(longitud > 32){
								char msg[150];
								sprintf(msg, "ERROR Lexico - Cadena \'%s\' demasiado larga. Maximo de 30 caracteres y contiene: %d", yytext, longitud-2);
								yyerror(msg);
							}
							return STRING_CONST;	
						}
{ID}        			{	strcpy(yylval.s, yytext);
							return ID;	}
{COMENTARIO} 			{	;	}
"\n"					{	;	}
"\r\n"					{	;	}
"\t"					{	;	}
" "						{	;	}
.						{	
							char msg[300];
							sprintf(msg, "ERROR Lexico - Caracter \'%s\' invalido", yytext);
							yyerror(msg);	
						}


%%
// [0-9]+(\.[0-9]+)?  {yylval.f = atof(yytext); return NUM;}
// strcpy(yylval.s, yytext);
